[00:00] This will be the only GitHub tutorial
[00:01] you'll ever have to watch in your entire
[00:03] life to have a full understanding of how
[00:05] to use this platform. And I'm going to
[00:06] teach this as simple as possible, as if
[00:08] you've never even used GitHub before,
[00:11] never coded in your life. So, anytime I
[00:13] say any type of complex term, I'm going
[00:15] to explain it as simply as possible.
[00:17] Because we all know the worst thing
[00:18] about any of these kind of tutorials is
[00:19] you're like, "Oh, I want to learn how to
[00:20] use GitHub." And then the person
[00:22] teaching it is just using all this
[00:23] developer jargon and you're like, "What
[00:25] are you saying?" Let's jump in. Welcome
[00:27] back, y'all. In today's video, we're
[00:28] going to be going over everything you
[00:29] need to know about GitHub. I'm going to
[00:30] make it so that by the end of it, you'll
[00:32] be an advanced user from start zero to
[00:34] start 10. We're ready to go. I knew I
[00:36] had to make this video because my video
[00:38] on the topic of how to learn how to use
[00:39] GitHub in 10 minutes is blowing up. I
[00:41] mean, that thing is just getting so much
[00:43] traffic where I was like, "Okay, I get
[00:44] it, y'all. Y'all want to get this style
[00:45] teaching on a topic like GitHub." So,
[00:47] the situation is pretty simple. First
[00:48] thing I want you to do is make sure to
[00:49] check out the description. There is
[00:50] going to be a ton of resources in
[00:52] regards to how to use GitHub. Don't
[00:54] worry, I'm not going to give you like
[00:55] some random FAQ link made by the GitHub
[00:57] team. I made custom Google docs that's
[01:00] going to show you everything I talk
[01:01] about in today's tutorial. Included in
[01:03] those docs are relevant videos showing
[01:04] you how to set that up as well. But
[01:05] let's just get going here. What is
[01:07] GitHub? Why do we use it? You're going
[01:08] to see it everywhere. It's going to be
[01:09] like cursb
[01:11] integrate GitHub. Why do I care? To put
[01:12] simply, at a fundamental level, what
[01:14] GitHub allows us to do is take that code
[01:16] that's on your nice little computer and
[01:18] essentially put it into the cloud. When
[01:21] I say cloud, that is essentially just
[01:23] the internet, Wi-Fi cloud. By taking
[01:25] that code that is found on your
[01:27] computer, and don't make it complex,
[01:28] y'all. What do you mean the code that's
[01:30] found on my computer? You know, like
[01:31] that folder on your computer that's like
[01:33] your project name, and I don't know what
[01:35] your project name is. Maybe it's just
[01:36] like best app ever. I know that
[01:38] spelling's not amazing, but it says best
[01:39] app, like the folder is called best app.
[01:41] That's literally just where your code
[01:42] is. We call that a repository. And this
[01:44] repository is in the cloud or the
[01:46] internet. Now, why do we do this? Like
[01:47] what is fundamental about this? And why
[01:49] do you see so many people just being
[01:50] like make sure you integrate with
[01:51] GitHub. Well, step number one here,
[01:53] version control. And here's what I mean
[01:54] by version control. If you're using
[01:56] cursor AI, VS Code, Windsurf, maybe
[01:59] Replet, wherever you're coding, this is
[02:01] going to put that in the folder. What
[02:02] version control allows us to do when we
[02:04] integrate into something like GitHub is
[02:05] it allows us to make checkpoints. When I
[02:08] say checkpoints, this is that old little
[02:10] software thing that you always see.
[02:11] You're like, why is it version one? Why
[02:13] is it v2? Essentially with GitHub and
[02:17] these commits and these PRs we're going
[02:18] to get into and actually do together in
[02:20] today's video. Think of it like that.
[02:22] Version control is you've created your
[02:24] app. It's version one. Nice little app.
[02:26] I love the app. It's version one v1.
[02:28] Well, guess what? Now using GitHub, when
[02:31] you create version two of that app,
[02:33] maybe uh maybe your app can copy this
[02:36] v2. We add a little crown to the app. So
[02:38] we add a little crown. That's v2. we can
[02:41] create this version control with GitHub
[02:44] where in theory we go to V2 where we're
[02:47] going down a little coding rabbit hole
[02:49] and we made V2 of the app and then we're
[02:51] like hold up this is trash we can burn
[02:54] V2 and come back to V1 version control
[02:59] that logic you can't do if you just keep
[03:01] that little folder on your cursor AI and
[03:03] it's all local code you can't do this
[03:05] version control which is extremely
[03:07] fundamental it's like playing Mario and
[03:09] you're in like level one of Mario and
[03:11] you know in Mario when they had like the
[03:13] little flags in the middle where like
[03:14] checkpoint flags. Yeah, you're basically
[03:16] playing Mario on hardcore mode where
[03:18] there is no checkpoint flags that you
[03:19] can revert back to. I mean, you can play
[03:21] that way. I don't want to play that way.
[03:23] Number two, or as classic top 10
[03:25] YouTubers speak, number two, collab. You
[03:28] want to collab with me? Collaboration.
[03:30] This allows you as an individual
[03:31] developer to create a team of developers
[03:33] or alternatively, everyone in the
[03:35] interwebs could collaborate on your
[03:37] relative code project. Now, in reality,
[03:39] in practice, depending on your use case,
[03:41] most of this would be maybe your
[03:42] developer A, and you're working with
[03:44] your friend, developer B. This allows
[03:46] developer A and B to work on the same
[03:49] repository and make changes. Now, I'm
[03:51] going to show you a very fundamental
[03:53] skill when it comes to collaboration in
[03:55] this video that you're going to need to
[03:56] know so you don't start overwriting each
[03:59] other's code. You get a bunch of errors.
[04:01] It's like a merge conflict. Those are
[04:03] the worst. I hate merge conflicts. I'm
[04:05] going to show you best practices when
[04:07] doing collaborations. But that's another
[04:08] reason why do we use GitHub, Corbin? To
[04:10] expediate software development because
[04:12] now we can collaborate with other
[04:13] humans. Some of you are like, Corbin,
[04:15] it's my project. No one else is
[04:16] collabing with me. It's okay. This is
[04:18] just for the people that want to collab.
[04:19] Another big reason is get free code. Why
[04:22] do we love GitHub? Because GitHub is a
[04:24] community of other developers that some
[04:26] have potentially open- sourced their
[04:28] repository of code. This is a whole
[04:30] thing. Now, some of y'all that might be
[04:32] coming into this space might be kind of
[04:33] confused on why people open source or
[04:36] make their code free. So, for me to best
[04:38] explain what free code is and what even
[04:41] open source means. Just think of it like
[04:42] this. Let's imagine there's two lemonade
[04:45] stands. One is on the side of the street
[04:46] and it's selling lemonade for a dollar.
[04:49] Everyone get their lemonade. It's a
[04:50] dollar. It's a dollar. But then you have
[04:52] another lemonade stand that is giving
[04:54] the lemonade out for free. People might
[04:56] be skeptical because of that, but you
[04:58] still go to the lemonade stand with the
[05:00] free lemonade. You try it. Maybe it's
[05:03] amazing. Maybe it's the best lemonade
[05:04] you ever had. Or maybe it doesn't taste
[05:06] that good, but you're like, "You know
[05:08] what? It was free. Let me just drink
[05:10] some free lemonade." You go over to the
[05:12] stand, it's a dollar. You pay for a
[05:14] dollar. You're expecting it to be good.
[05:16] You put money into it. What I just
[05:18] described there is the difference
[05:19] between open- source free code and maybe
[05:22] just a straightup software company
[05:23] selling you a service. If you're buying
[05:25] a software company service, you're
[05:27] expected when you pay for something to
[05:29] get value and it works. When you go to
[05:32] the open source free code and you
[05:33] download an actual app that functionally
[05:35] could work, some open- source code
[05:38] that's free is absolutely amazing.
[05:41] What's an example of this? You can quite
[05:43] literally download a very advanced model
[05:45] from DeepSeek for free and have it
[05:47] locally on your computer. I'll leave
[05:48] that in the description down below. But
[05:50] the idea is that some source code or
[05:52] free code is just like not good at all
[05:54] too. So you just got to find out the
[05:55] good stuff. And one thing that GitHub
[05:57] does really well is because this is a
[05:59] community of developers, you're going to
[06:01] see how many stars a repo has. That
[06:03] means like, hey, I like this repo, how
[06:05] many forks a repo has. Don't worry, I'll
[06:07] explain what a fork and a star is soon
[06:09] here. I just want to give the general
[06:10] overview first. So third reason to get
[06:12] access to GitHub is guess what? Let's
[06:15] get some free code. And I'm going to
[06:16] show you today how we actually download
[06:17] free code and run free code. So, there's
[06:19] other reasons why we use GitHub. I could
[06:21] keep going on here, but the last one
[06:22] that's major to me personally and maybe
[06:24] major to you as well is real business.
[06:26] And what I mean by real business, as I
[06:28] run my own software company here, is
[06:29] that if you genuinely have employees or
[06:32] you work with multiple developers and
[06:34] this is an actual product, you have to
[06:36] use something like GitHub. GitHub allows
[06:38] us to take what you originally would
[06:40] have had, which is what we call a monor
[06:42] repo. Corbin, what do you mean monor
[06:43] repo? So for example, if I come back to
[06:45] our, you know, app up here, V1 app, what
[06:48] a monor repo is is that means one
[06:50] repository, which means that all the
[06:53] relevant code found in the app. This
[06:55] right here, monor repo told you when I
[06:58] use developer jargon, I'm I'm going
[06:59] explain it. So monor repo, all your
[07:01] relevant code for the app is inside the
[07:03] app. eg the front end and the backend.
[07:06] We'll just make it super general, right?
[07:08] Just to make our lives easy. front-end
[07:09] code and the backend code, your React
[07:11] tech stack, your whatever tech stack you
[07:14] like using in the front end, front end
[07:15] code and your backend code, AWS, GCP,
[07:18] Firebase, like whatever you like to use
[07:19] in the back end, backend code, one
[07:21] folder. What GitHub allows us to do is
[07:25] essentially create what we call a poly
[07:27] repo. What a poly repo in the name poly
[07:29] many means essentially that that one
[07:32] little folder that model re the one
[07:34] folder
[07:36] turns into maybe four different folders.
[07:38] My original folder with all of the fun
[07:40] stuff in it all the app code will break
[07:43] into maybe four folders maybe five
[07:45] folders. Maybe six folders. You might be
[07:47] like Corin why is there so many folders?
[07:48] What does that mean? That means what it
[07:51] allows us to do is now I can create a
[07:54] folder depending on the specific parts
[07:56] of the app. This is when applications
[07:58] get very big. So for example, maybe one
[08:01] part of this folder is all the front-end
[08:03] code. Maybe one part of this folder is
[08:06] all the stripe monetization code. I'll
[08:09] just do stripe code because that is a
[08:10] big part of an application is how you
[08:12] monetize. Maybe we want to separate and
[08:14] granularize that code into its own
[08:15] separate folder. Maybe one part of the
[08:17] folder is your custom pipeline. Now let
[08:20] me give you a real example of this. This
[08:22] company right here, this is the software
[08:23] company I run. And from what I remember,
[08:26] we have around 10 different folders.
[08:28] Each folder representing a different
[08:29] part of the application that then comes
[08:32] together. Another advantage of doing
[08:33] poly repo is it allows us to code
[08:36] faster. What you'll realize when you do
[08:39] GitHub, when you do coding and you're
[08:41] pushing it to an actual real website or
[08:44] software, whatever the heck you're
[08:45] building, maybe you're building the next
[08:46] Minecraft, it takes time to push that
[08:48] code. But if you granularize it in a
[08:50] poly repo, then all we have to worry
[08:52] about when we do a push and what you
[08:54] might be like, Corbin, what the heck do
[08:55] you mean push? Push essentially means
[08:57] essentially taking that code locally on
[08:59] your computer and putting it into the
[09:01] cloud and then congrats, it's live on
[09:03] your website. Eg. I come to my website,
[09:06] bumpups.com. I make a change in the
[09:08] frontend code here locally. I render
[09:10] that. I'm like, yo, I need to put this
[09:12] in the cloud. I push it to the cloud and
[09:14] it'll show up at bumpups.com. the
[09:17] website link everyone has access to that
[09:19] push happens faster when it's multiple
[09:22] folders. Another advantage of using a
[09:25] poly repo when it becomes a real real
[09:28] business with multiple devs is it
[09:31] essentially allows it so that when you
[09:33] have dev A we'll use a different cover
[09:35] color y'all. We'll say like gray dev A.
[09:37] Hi I'm dev A is someone's name dev A.
[09:40] When you have dev A here, dev A with the
[09:42] nice little legs, we don't have to do
[09:44] the monor repo situation where
[09:46] essentially, hey, I just hired you.
[09:48] Here's your W2. Here is your monthly
[09:51] income. Here's your annual income.
[09:53] Here's like uh options and equity. Let's
[09:55] have some fun. We don't have to give dev
[09:57] A access to the entire application, all
[10:00] of the code. You're probably thinking to
[10:02] yourself, that probably wouldn't be a
[10:03] smart idea. But we can give dev a maybe
[10:05] access only to the front-end code, but
[10:06] no access to stripe code, custom
[10:08] pipeline, other backend functions that
[10:10] incur within the application. This point
[10:12] right here, don't worry about it if
[10:13] you're completely fresh. Just don't even
[10:15] worry about it. Come back to this video
[10:16] in the future when you're like, you know
[10:17] what, I'm ready to take the next step
[10:18] and then dive into an AI model about
[10:20] this topic. All you need to care about
[10:22] right now short term is Corbin, I have
[10:25] one application. It's all the code's in
[10:27] the same folder. What do I do? That's
[10:28] going to be your monor repo. Let's
[10:30] proceed. So, we'll take a real quick
[10:31] look at just your GitHub. UI. Other
[10:34] words, user interface. Corbin went to
[10:36] user interface. This stuff. Oh, look at
[10:38] this. I hover over the link and a little
[10:40] box comes up. I hover over my name and
[10:42] it says change avatar user interface.
[10:44] Also, I'm not trying to patronize y'all
[10:46] when I talk like that. I'm I'm genuinely
[10:48] just trying to get the information out
[10:49] as simple as possible. You have to
[10:51] understand when especially for my other
[10:52] GitHub video or anytime I do a tutorial
[10:54] video, it's very much like I get
[10:55] comments like, "This guy still didn't
[10:56] make it simple enough." I'm trying to
[10:58] make this as simple as possible. Y'all
[10:59] scrolling down here. Obviously, you have
[11:01] your own little profile. your profile
[11:02] can connect with other people. You can
[11:03] come over and follow me. Link tree in
[11:05] the description down below. And you can
[11:06] see I have four projects here. These
[11:08] four repositories, projects, whatever
[11:10] you want to call them, open source. You
[11:11] can download them. This comes from my
[11:12] backend playlist. This comes from a
[11:14] entire playlist that shows you how to
[11:16] build out a software from literally
[11:18] scratch as that is fundamentally
[11:19] important to know. This is a three and a
[11:21] half hour playlist. Pretty cool. But the
[11:22] idea is that when you have a public
[11:24] repository, so I can click into this.
[11:26] You will notice that there is stars and
[11:29] forks. Stars. What does that mean? That
[11:31] means that me personally, when you have
[11:33] your GitHub profile selected, if you
[11:35] start a repository, it's kind of like
[11:37] bookmarking. That's all I want you to
[11:38] think about about it. I want to come
[11:40] back to this nice little git repo. Also,
[11:43] you know, the actual developer that made
[11:44] the git repo, it looks kind of cool.
[11:46] Like, yeah, actual backend app. I got 36
[11:49] stars. You know, you're just giving me a
[11:51] like. Okay. Fork. Essentially what a
[11:53] fork does and when I say fork I'm
[11:54] referencing this is that it's taking the
[11:57] repository itself all this code found
[12:00] here and it's creating an exact
[12:02] duplication but in your profile and what
[12:05] that allows you to do is it allows you
[12:07] to make changes here and then do
[12:09] whatever the heck you want. And then
[12:10] there's one extra layer to that where if
[12:12] you fork it, then essentially you make a
[12:14] change. In theory, you could come back
[12:16] to like we'll just call this the alpha
[12:19] repository and be like, "Hey Corbin, I
[12:21] made this change. Here's a PR request,
[12:24] pull request, a change from the original
[12:27] duplication. Can you add it?" And then
[12:29] I'll probably just be like, "No, I'm
[12:31] just playing y'all." But that's the
[12:32] situation there. In the short term, all
[12:34] you need to care about is Corbin
[12:36] repository. That's your folder on your
[12:38] desktop. How do we connect that? But
[12:40] before we dive over to Cursor AI and I
[12:42] show you some really cool git commands,
[12:43] some skills, and everything you should
[12:45] know in this kind of development, let me
[12:46] show you something you need to set up on
[12:47] your profile. So, if I come over to my
[12:49] profile here, I hit the top right, and
[12:51] then we come over to settings. Once
[12:52] you're in your profile, you're going to
[12:54] simply come here to SSH GPGs.
[12:57] The only one you're going to care about
[12:59] here is your SSH key. That sounds
[13:01] extremely confusing, I know. So, what I
[13:03] did was I created an entire Google Doc
[13:06] setup guide for this description down
[13:08] below. And it quite literally has an
[13:10] entire video dedicated to this topic to
[13:13] show you exactly how to do this. Your
[13:15] next question might be, Corbin, why the
[13:16] heck do I need an SSH key? Let me show
[13:18] you why. We have a laptop or desktop or
[13:21] some of y'all even crazy. You can do
[13:22] this on your phone now. I made some
[13:23] crazy videos. Check it out. I did a
[13:25] whole video where I was literally
[13:27] developing an app. This is no joke. Yo,
[13:28] I was developing an app on my phone on
[13:30] the back of a motorcycle in Bali. Don't
[13:32] believe me? Look up Corbin riding
[13:34] motorcycle jacket. You got your laptop.
[13:36] Your laptop has our nice little code
[13:38] file, right? So, we have our nice little
[13:40] nice little folder. This is my beautiful
[13:42] app. This is a multi-billion dollar app.
[13:44] Has your app and it's local and really
[13:46] like overarching idea of what it means
[13:48] when it I say local is that if your
[13:51] computer straight up dies, destroyed,
[13:54] cap, you will never be able to get this
[13:57] app thing again. If it was never pushed
[13:58] in the cloud or you never put in Google,
[14:00] like you you're just never going to be
[14:01] able to get it. you lose all the code.
[14:02] That's high level. Idea though is that
[14:03] you have it locally on your computer,
[14:05] but your computer has no connection to
[14:08] GitHub. So we come over here. This
[14:10] little green box will just say is
[14:13] GitHub. So let me go ahead and just
[14:14] write GitHub. As of now, your computer
[14:16] doesn't even know what GitHub is. It's
[14:18] like what's GitHub? What are you talking
[14:19] about? It has no connection to GitHub.
[14:20] So we'll add a nice little like barrier.
[14:23] So the name of the game is how do we get
[14:24] this local code over to GitHub? But how
[14:26] do we do it in a way where we aren't
[14:28] frustrated? Eg. There is ways that you
[14:32] can kind of do like very fast
[14:33] troubleshoots. If you're talking to Chad
[14:35] GBT, you're talking to Claude. Sometimes
[14:37] it will tell you, hey, don't worry. In
[14:40] order to connect your code repository
[14:41] from GitHub to your computer, use
[14:44] something called an access token. Don't
[14:46] do that. It's too much effort than it's
[14:48] worth. It's really not a long-term
[14:50] solution. So, set up this SSH key
[14:53] because what this SSH key essentially
[14:55] does is it basically tells your GitHub
[14:57] profile, you over here. Yeah, nice
[15:00] profile pick. I like it. You over here,
[15:03] it tells GitHub, hey, you own this
[15:05] computer. You should have full access
[15:07] when you do all your git commands, when
[15:08] you do any type of pushing, any type of
[15:10] pulling, you have access completely to
[15:13] your own GitHub profile and it's
[15:14] associated with your laptop, your actual
[15:16] piece of hardware. Fundamentally
[15:18] extremely important that you know that.
[15:20] Therefore, how do we make sure that this
[15:22] access even occurs? What is the key? #
[15:24] major key alert 2016 circa DJ calate
[15:27] alert like that situation that is going
[15:30] to be the SSH keys
[15:33] key coming over to get here. This is
[15:34] where you're going to set it. You're
[15:35] simply going to go a new SSH key and
[15:37] there's a lot of terminal commands
[15:39] associated with this y'all. And that's
[15:40] why I created this doc for you. You
[15:42] scroll down. It goes over all the
[15:43] terminal commands. And before I get
[15:45] absolutely spammed. Before I get
[15:47] absolutely spammed. Corbin, did you do
[15:48] this for Windows and Linux? I did Mac,
[15:50] Windows, Linux, all of it. Check out the
[15:52] doc. So that's that situation. And
[15:53] that's how we connect our piece of
[15:55] hardware, our laptop, our desktop,
[15:56] whatever you're using into our git
[15:58] profile. Therefore, we save ourselves a
[16:01] huge headache when doing commands where
[16:03] we get like, hey, you don't have access
[16:05] to this. Oh, um, you were trying to
[16:07] access that private repository that you
[16:09] created. Yeah, funny. You don't own
[16:11] that. And you're just kind of sitting at
[16:12] your computer like, what are you talking
[16:14] about? I just made it. What do I not
[16:15] own? That solves that situation. Check
[16:17] out that doc and the video associated.
[16:19] I'll leave the video down in the
[16:21] description down below because it takes
[16:22] around 10 minutes to set that up. But
[16:23] once you set that up, we are looking
[16:25] good so far because now we've done layer
[16:28] 2 here. You've set up our local machine.
[16:30] That's what they call it sometimes. You
[16:31] know, developers just want to call
[16:32] everything so fancy. Local machine to
[16:34] GitHub. The next thing you need to do is
[16:36] that great, you've connected to GitHub.
[16:38] But the issues you're going to be
[16:39] running into then is going to be like,
[16:41] "Hey Corbin, when I use cursor AI and I
[16:43] do a git command, it's going to say get
[16:45] not found. What are you talking about?
[16:46] Who's git?" or when you try to install a
[16:48] React front end, it's not going to know
[16:50] what it is because it's going to be
[16:51] like, "What's npm mean?" So all those
[16:53] little nuances of like, "What are you
[16:55] talking about? You don't own this.
[16:57] What's a get that very frustrating,
[16:59] annoying stuff?" I'm going to leave
[17:00] another Google doc in the description
[17:02] down below and another entire video
[17:04] dedicated to that. By the way, if you
[17:06] want to see what the video is, just hit
[17:07] original video, click it to set that up
[17:09] so you get to the point of having a
[17:11] fully ready to go developing IDE.
[17:14] Corbin, what's an IDE? integrated
[17:16] development environment cursor AI VS
[17:18] code winds surf situation is that
[17:21] description down below proceed so now
[17:23] we're going to get to the part of the
[17:24] tutorial where we start doing some
[17:25] commands together and we start playing
[17:27] around in cursor AI play around in
[17:29] anything you want and seeing how we can
[17:31] actually start using GitHub and if you
[17:33] stayed with me up to this point make
[17:34] sure you leave a like it's completely
[17:35] free I know the beginning part of this
[17:37] video you're like this was a lot of
[17:38] explaining trust me a lot of stuff on
[17:40] YouTube they just don't explain enough
[17:42] okay so I wanted to give everything in
[17:43] this video let's do it though so the
[17:45] example we'll we'll do today is we'll do
[17:47] an AI YouTube timestamp. So, what this
[17:50] was is I open sourced an entire software
[17:52] so y'all could see from start to finish
[17:54] and I created an entire series around
[17:56] it. If I scroll down here, you can watch
[17:57] the entire series. Boom. Text stack
[18:00] setup, front end, backend, monetization,
[18:01] launch, don't do this, full guide,
[18:03] everything. We're going to download this
[18:04] code. We're going to steal the code. If
[18:06] you're wondering what software this was,
[18:08] just type in tubestamp.com. This is the
[18:10] software we created together. put a
[18:12] YouTube link, generate timestamps, get
[18:13] in different languages, everything like
[18:15] that. So, let's say we find ourselves in
[18:16] a situation we're like, "Yo, I really
[18:18] like this code." Once you set up your
[18:20] SSH key and once you did the setup
[18:22] process of installing Node.js and
[18:24] everything I showed you before, now all
[18:26] we need to do is hit clone repo. Once we
[18:29] hit clone repo, we can come back to that
[18:31] GitHub page. I'm simply going to say
[18:33] code SSH and then copy this. Note the
[18:36] reason I can get away with SSH is
[18:39] because we set up our SSH key. Clone
[18:41] repo. Paste. Enter. Once you do that, it
[18:45] will give you the option of either
[18:46] selecting a pre-existing folder or just
[18:48] creating a new one. So, we'll say new
[18:49] folder. And we can call this my code.
[18:51] But in reality, call it anything you
[18:53] want. But whatever you call it, make
[18:55] sure you like the name as this is going
[18:56] to be where all the code is actually
[18:57] going to be downloaded to. So, we say
[18:58] create. Once I create that, I'm going to
[19:00] say select repository destination. Boom.
[19:02] It's going to ask to open it. We're
[19:03] going to say open. And here we go. This
[19:04] was able to download all that code that
[19:06] we just had in git repository. And what
[19:08] I mean by that, for example, app.js.
[19:11] What do we notice in the app.js? It says
[19:12] to stamp is a free online tool. Okay,
[19:15] coming over to the GitHub profile, we go
[19:17] to source as in source here and we go to
[19:20] the source where we downloaded the code.
[19:21] We go to app and look it exact same line
[19:24] shows up. Tub stamp is a free online
[19:25] tool blah blah blah. So now we have that
[19:28] git repository and a carbon copy of it
[19:30] complete duplication in cursor. Now,
[19:32] let's get to the next part of this
[19:33] tutorial, which is going to show us how
[19:34] to do pull request. What is a pull
[19:36] request? What is the value of a pull
[19:38] request? Then, we're going to do get
[19:39] commits together. Very fundamental git
[19:41] commits that you're going to type so
[19:43] much that sooner or later it's just
[19:45] going to be burned into your brain.
[19:46] Trust me, at this point, I can just type
[19:47] them out like I probably recite them in
[19:49] my sleep. That's how much you're going
[19:50] to do them. Okay, let's go and jump over
[19:51] to cursor here. Let's learn how we kind
[19:53] of just communicate between our local
[19:55] code and the code in the cloud. But
[19:57] before we start diving into terminal
[19:58] here, we got to connect this local code
[20:01] and create a new Git repository for it.
[20:04] So to do that, we're going to come back
[20:05] over here to GitHub. We'll click
[20:06] repositories. Once you're on this page,
[20:08] come up here to new here. Give it a name
[20:10] you'll know. So I'll just say my code
[20:11] for now. Here we go. Can add a
[20:13] description. Fun times. And everything
[20:15] else you can kind of leave standard.
[20:16] We're going to say create repository. So
[20:17] what you'll notice here is that now it's
[20:19] like an empty project that we need to
[20:21] connect. What's very important here that
[20:23] we care about is the SSH link which is
[20:25] found here. So, we hit copy here. Now,
[20:27] to be honest with you all, Cursor AI and
[20:28] all these different AI integrated IDEs
[20:30] have gotten so good with this chatbot
[20:32] feature that in theory, if you don't
[20:34] want to do what I'm about to show you
[20:35] right now, you could simply just ask the
[20:37] chat, hey, I've connected my profile
[20:39] with an SSH key. Here is my GitHub SSH
[20:42] link. Connect this local code and it'll
[20:44] probably do it for you. But
[20:44] fundamentally, it's always important to
[20:47] learn a skill how we used to do it back
[20:49] in the old days. Okay, so we're going to
[20:50] come down here. We're come over to
[20:51] terminal. Once we're in terminal, notice
[20:53] how we're in the actual thing. AI
[20:55] YouTube time stamp. Nice. And we're
[20:57] going to go and get these lines.
[20:58] Obviously, grab these lines from AI
[21:00] model. It's going to be get initialize,
[21:02] get add, get commit-m initial commit.
[21:05] Very first commit. You'll see what that
[21:06] means. Get remote add origin. So now
[21:08] we're identifying within the folder
[21:09] itself where we want to always push
[21:11] these kids to locally to the cloud. And
[21:14] the origin is that coffee fuel bump my
[21:17] git which we created here. And the
[21:20] reason it's called my code if you
[21:21] remember is because we named the
[21:23] repository my code and then get push u
[21:25] origin main. What does main mean here?
[21:28] Main is essentially the branch name. Now
[21:31] I ran into an error. Look at that.
[21:33] Remote origin already exists. So instead
[21:35] of me showing you how I troubleshoot
[21:36] this in the old ways, we can just ask
[21:39] the AI to do it for us. I'm going to
[21:41] simply say push this local code to my
[21:43] git repo. This is my first commit. I
[21:44] want to give context to the AI. Provide
[21:46] the SSH link that we just had and hit
[21:48] enter. And here we go. So let's just say
[21:50] I'll help you push your code to the
[21:51] GitHub repository. Notice how now cursor
[21:53] gives the underlying steps. And one
[21:55] thing that's extremely impressive that
[21:57] you know it wasn't like this one or two
[21:59] years ago is that when it sees errors,
[22:01] AI used to be like, hey, here's an air.
[22:03] Have fun. Now it just autocorrects
[22:05] itself. So to show you this working
[22:06] right now, this is the repo with no code
[22:08] pushed. Right? I look at it, I don't
[22:10] like it. We're going to let cursor keep
[22:11] pushing here. And supposedly it
[22:13] successfully pushed the code. I'm going
[22:14] to reload. And look at that. This is
[22:15] just I mean I could go on a whole
[22:16] another tangent about AI and IDEs and
[22:18] you can check out this channel here if
[22:20] you want to see how to even leverage
[22:21] this even further. But the point being
[22:23] basically if you run into errors now
[22:24] don't even worry most of these IDEs can
[22:26] handle it. So there we go. We got our
[22:28] code pushed into GitHub. Let's do some
[22:30] push and pulls with it. And just to
[22:31] prove it to you what you'll notice is
[22:32] this initial commit. Go to source you
[22:35] know app.js app.css. Everything is
[22:37] looking good here. So sometimes what I
[22:38] do in terminal is I'll just make a new
[22:39] terminal window. Let's freshen the slate
[22:41] here. I'm going zoom out for y'all a
[22:42] little bit and let's make our first
[22:44] commit together. And what a commit is
[22:45] essentially is that we're taking local
[22:47] code code that exists on our computer
[22:49] and we're pushing a new update to the
[22:52] cloud. So for example, if we come to our
[22:54] readme here, it says all lessons are
[22:55] available on YouTube. Click any title to
[22:57] watch. This is true. I can simply just
[22:58] delete this cuz maybe I don't want to
[23:00] give that CTA. And I could save it. And
[23:02] now we can go ahead and push that. And
[23:04] to push it, we're going to do get addit
[23:07] commit-m. And then you're going to tell
[23:10] what this commit is. I'm going to say
[23:11] changed readme. This can be as specific
[23:13] as possible or alternatively just random
[23:15] gibberish but you're like I just need to
[23:16] throw a save point in there. I'm going
[23:18] to hit enter. Once I do that, I'm going
[23:19] to do get push origin and then the
[23:22] branch name. So your next question might
[23:23] be Corbin, how do you know what the
[23:25] branch name is? There's multiple ways to
[23:27] see this. The first way to see this, you
[23:29] will notice in the bottom left of your
[23:31] IDE, it will say the branch name. So
[23:33] right now we're in main. Nice.
[23:35] Alternatively, this is the command get
[23:37] branch. Boom. Maine. And it's going to
[23:39] identify with it being green. Another
[23:41] way is coming over to GitHub. You'll
[23:43] notice his main iss right here. I can
[23:44] reload and you'll notice that we have a
[23:46] new push here. And then you'll notice it
[23:48] says changed readme. But how do we read
[23:49] that in an itemized way? We come over
[23:51] here to commits and then you can see it
[23:53] here. Changed readme. Click it. One file
[23:56] changed. And it's what we changed
[23:57] together. Nice. Now, let me show you an
[23:59] example of you went crazy and you just
[24:02] completely burned yourself and you're
[24:04] like, "Yo, Corbin, I need to roll back
[24:06] pronto. I got you." Let's say we come
[24:08] over here and you know we're messing
[24:10] with the code and I'm just like you know
[24:11] what I don't like any of this code. This
[24:12] is all horrible. I don't like it. You
[24:14] know I save this and then you know for
[24:16] some reason I'm crazy and I push this.
[24:17] Get add get commit dashm l code get push
[24:22] origin main. Right. So obviously the
[24:24] assumption here is that you went down
[24:26] some rabbit hole. You were actually
[24:27] trying to make real code but then at a
[24:29] certain point you found yourself
[24:30] creating so many files so many different
[24:32] things that you were like okay this is
[24:33] just too much to even revert. And then
[24:35] what you'll notice, you know, come back
[24:36] to main. We're like, "Holy smokes, L
[24:38] code. The code just turned into an L. We
[24:40] don't like this." You go to your commits
[24:41] and it's like, "What do I do, Corbin? I
[24:43] need to go back to change read me
[24:44] because at least I know and change read
[24:45] me the code was like fine and it wasn't
[24:47] completely broken." To do that, you're
[24:49] going to simply come over to here and
[24:50] you hit copy full. It's going to be a
[24:52] string. And the string represents a
[24:54] specific commit on that specific repo on
[24:56] your specific profile. I know that sound
[24:58] confusing, but basically it's a save
[25:00] checkpoint. You're playing Mario and
[25:01] maybe you want to redo a checkpoint and
[25:03] you go back in time or maybe like better
[25:05] examples like Skyrim. I know y'all know
[25:06] Skyrim. Skyrim is an OG. Please come out
[25:08] with a new game that's like a new
[25:09] Skyrim. I love Skyrim. It's like when
[25:11] you go to Skyrim, you are going to
[25:13] Winterfold. You do fuss ra you kill the
[25:15] entire village and you're just like,
[25:16] "Wait, there's too many guards on me.
[25:19] Let me save. Let me go to my save
[25:20] checkpoint before I did Fousea." That
[25:23] thing. If you have no clue what Skyrim
[25:24] is, you're like, "What is this guy
[25:25] rambling about?" Just trust the process.
[25:26] Now, there's two ways we can approach
[25:28] this. Some of y'all are going to be
[25:29] oldfashioned like me and you'll probably
[25:30] just do a terminal command to roll back
[25:32] to this or just, you know, we're in a
[25:34] new age. We can essentially just come up
[25:36] here to a chatbot and ask for it to roll
[25:37] back for us. So, I'll go ahead and put
[25:39] please roll back to this GitHub commits.
[25:41] I'll paste what I copied. Hit enter. And
[25:43] this stuff's just impressive, y'all. No
[25:45] longer do you really need to understand
[25:46] to a fundamental level terminal
[25:48] commands. You just need to know how to
[25:50] talk to it to get the best results. And
[25:53] there we go. We fundamentally pushed
[25:55] back to that specific commit. Now,
[25:56] sometimes this might do the wrong thing
[25:57] because obviously it's AI. So, let me
[25:59] make sure this is actually correct,
[26:00] y'all. So, right now it's doing this the
[26:02] safe way in the sense of like, yo, like
[26:03] we're going to make a separate branch to
[26:05] make sure that you know whatever you had
[26:06] in your original No, no, no. We're going
[26:08] to force push this. To do this, we're
[26:09] going to use the terminology of force
[26:10] push this, commit to main, commit
[26:12] string, make a new head. When you hear
[26:14] head, basically, it's like the head of
[26:16] the snake. Sometimes it will separate it
[26:18] because it want to destroy the snake. I
[26:19] know that sounded very confusing. All
[26:21] you got to know is that a force push
[26:23] makes it so that you're going to see
[26:24] main below me. And look it main's right
[26:26] here which is typically what you want so
[26:28] that we can come back and look it the
[26:29] commit is now changed to readme commits
[26:31] l code push disappeared. Nice. Cool. So
[26:35] now you know how to take your main
[26:36] branch push some new code into the cloud
[26:38] and you also know how to revert some
[26:40] code. So if you go down a rabbit hole
[26:42] it's no good. But let me show you a
[26:43] fundamental skill of what we call a pull
[26:45] request which is going to be us creating
[26:47] a separate branch. But let me explain a
[26:49] little bit further what that means. We
[26:51] got Timmy here and Timmy is using
[26:52] GitHub. Timmy has the most amazing app
[26:54] idea. It's it's absolutely amazing. He's
[26:56] telling everyone about it in the group
[26:57] chat. Timmy's app is currently just on
[26:59] the main branch. So what the branch
[27:01] we've been working in, right? That's all
[27:02] Timmy's been doing. Just straight
[27:04] deployments to main. Deployments to
[27:06] Maine. Deployments to main. At a certain
[27:08] point, this is an inefficient way to
[27:10] code. And the reason this is an
[27:12] inefficient way to code is because of
[27:15] the fact that you're putting Maine in a
[27:17] high risk position. Because when this
[27:19] code becomes real code and when I say
[27:22] real code I mean like it's an actual
[27:24] software or website you need to protect
[27:27] main at all cost as main is going to be
[27:30] the code that is production level ready.
[27:33] What I mean by production level ready
[27:35] hashtag production is essentially code
[27:38] that is currently actively in the cloud
[27:40] running and people are paying for it or
[27:43] maybe it's a free service maybe it's
[27:45] free but the point is that people are
[27:46] using it. Therefore, the code that's in
[27:48] production has to be spotless. It has to
[27:50] be no issues. That's why when you use or
[27:54] play a video game or you use a website
[27:56] and it's buggy, that's an issue. That's
[27:58] what we call a patch. That's what we
[28:00] call a I'm playing Call of Duty. I'm
[28:02] trying to get new skins. Why is it when
[28:04] I go to this part of the map, I just
[28:05] start going like this? Well, that's
[28:07] because there's a bug in the game.
[28:10] Production code is supposed to be clean.
[28:11] Therefore, in order to ensure production
[28:12] code stays clean, and there's a bunch of
[28:14] other reasons why, guys. In order to
[28:15] ensure production code stays clean, we
[28:17] protect Maine at all costs. Therefore,
[28:19] how do we make it so that Timmy over
[28:20] here isn't just absolutely going crazy
[28:22] on Maine? Well, that is when a pull
[28:26] request and a separate branch of Maine
[28:28] is made. So, let me explain this. And I
[28:30] explained this in the 10-minute video,
[28:31] so some of you already know this, but
[28:32] it's always nice to rehear
[28:34] so you really stick with it. Maine. What
[28:37] is Maine? Maine is the code found in
[28:40] this branch. We love Maine. Maine is
[28:41] going to be production. Maine is going
[28:43] to be the code we push all the time. But
[28:44] when we want to do a pull request, we
[28:46] are essentially making a exact
[28:48] duplication of main. It is the exact
[28:50] same code, y'all. Exact same. We're
[28:52] calling it something else. So maybe not
[28:53] main, maybe it's a new feature. This new
[28:56] feature allows you to put up profile
[28:57] picks. So maybe we call the branch just
[28:59] profile. So now at the bare roots, and
[29:01] I'm going to show you all how to do this
[29:02] like actually on GitHub, but at the bare
[29:04] roots, we have identical branches that
[29:07] were just created. One called profile,
[29:08] one called main. But obviously when I
[29:11] make a change in the profile branch, it
[29:13] starts to look different than Maine. And
[29:16] slowly the profile branch becomes a
[29:18] whole new breed and animal of our
[29:21] original app. When the profile branch
[29:23] gets to a certain point of being like,
[29:25] "Hey, this looks good." That is when we
[29:27] take the profile branch and we do
[29:29] something called a PR. We're going to do
[29:30] this. Don't worry, y'all. I know this
[29:32] might be confusing because we haven't
[29:33] done it together, but we're going to do
[29:34] it together. A PR is a pull request. And
[29:36] what a pull request does is it will
[29:38] cross reference the main branch, the
[29:41] original where it all started, the
[29:42] chicken or the egg, the chicken and the
[29:44] egg maybe. But the main branch is going
[29:46] to cross reference a profile. It's going
[29:48] to first identify is there any what we
[29:51] call merge conflicts. Now merge
[29:53] conflicts is like the boogeyman of
[29:54] software development. It is extremely
[29:56] annoying to deal with. But essentially a
[29:58] merge conflict is that when there was
[30:00] something you did in this new code that
[30:02] essentially conflicts with the main
[30:03] branch, the production branch, the code
[30:05] we're not supposed to break, right? So
[30:08] when you get a merge conflict, it could
[30:10] either be a big deal or alternatively
[30:12] you did that on purpose because you're
[30:14] like this one feature that is in
[30:16] production code. Yeah, we're just like
[30:18] that's trash. We need to do a completely
[30:20] new feature. So you're going to have
[30:21] inherent merge conflicts that are
[30:23] incurred there. There are situations
[30:25] though and probably in most situations
[30:26] with merge conflicts where the actual
[30:28] code that you're trying to merge my
[30:30] profile branch back into main. Oh,
[30:33] that's an issue. We want to keep the
[30:35] main branch stable where we don't have
[30:37] that conflict. So, we solve it by maybe
[30:39] having the main code, the code found in
[30:41] the main branch override the profile.
[30:43] We're going to do this all together. But
[30:44] the idea is this. Using this
[30:46] methodology, using this method of
[30:47] coding, it also opens the door for
[30:49] collaboration. So, we have PR. You made
[30:51] your profile. Nice. It's a beautiful
[30:53] profile. But what also happened was that
[30:55] while you were working on profile, you
[30:57] were the best profile creator in the
[30:58] game. Someone else on your team was
[31:01] working on item, new items. So, we'll
[31:04] say new. So, we'll just call this branch
[31:06] new item. I know my spelling is not
[31:07] amazing. Someone else was working on new
[31:09] item and they copied the code directly
[31:11] from main and then they went down their
[31:13] little rabbit hole of new item branch.
[31:15] So, we'll just say new for now, but new
[31:17] item branch. Now, typically in software
[31:18] development, if you do it correctly, new
[31:20] item branch and profile, there should be
[31:22] no issues here. You should never really
[31:24] have an issue where you really hit each
[31:25] other. No car crashes. Sometimes it
[31:27] happens, sometimes it doesn't. It just
[31:29] really just comes down to like, hey
[31:31] Timmy, I know you're working on profile,
[31:32] but why'd you touch my files in this
[31:35] area of the repository and you're
[31:37] causing a conflict? You know, the yin
[31:39] and yang of software development is when
[31:40] you have a really good front-end
[31:41] engineer and a really good backend
[31:42] engineer. That's the yin of all yangs
[31:44] because that allows it so that the
[31:46] front-end guy or gal can just code code
[31:50] code code and so can the backend person
[31:52] and there really isn't any merge issues
[31:54] there. When you have two full stack
[31:56] engineers it's good that's really good
[31:58] but sometimes you can have an issue
[32:00] where one full stack engineer when I say
[32:02] full stack that means you're really good
[32:03] at nice little zoom zoom back out AI
[32:05] camera. When I say full stack that means
[32:08] that the engineer knows how to do front
[32:10] end and back end at a sufficient level.
[32:12] could run into some issues there. But
[32:13] obviously the more you know the better.
[32:14] Let's actually do this though in
[32:16] practice. And the last little note here
[32:17] is that obviously when you have multiple
[32:19] branches PRs, it expediates the S3
[32:21] development workflow. To do this in
[32:22] practice though, we do this. I'm going
[32:24] to do get branch. All right, we're on
[32:25] main. Nice. I'm going to do get branch.
[32:27] Get checkout-b. And this is going to be
[32:30] what we call our branch. So maybe our
[32:32] branch is, you know, I don't like the
[32:33] name stamp. So I'm going to say like
[32:35] rename. Okay, perfect. Now when I do get
[32:37] branch again, notice bottom left it says
[32:40] rename. And also notice that the
[32:41] asterisk is green next to rename. Now to
[32:43] be clear, as you already saw earlier in
[32:45] this tutorial, if you don't like these
[32:46] commands or they look scary, you can
[32:48] probably ask Cursor AI to do the same
[32:49] thing. Hey cursor, can you make me a new
[32:52] branch called this? And then it'll
[32:53] probably do it for you. Cool. We're in
[32:55] rename. First thing you'll notice is
[32:56] that if you go back to your GitHub
[32:58] profile, rename's not here. And you'll
[33:00] be like, Corbin, where's rename? I just
[33:02] made a branch called rename. What's
[33:03] going on? That's because it's still
[33:05] locally on your computer. You first have
[33:06] to do a commit. What I mean by that is
[33:07] maybe we don't like tube stamp. Maybe we
[33:09] like coffee is good. That's the new name
[33:12] of this platform. I hit save. And then
[33:15] when I do get add commit, you know, get
[33:18] add dot getit commit and then do, you
[33:20] know, nice name. It's a beautiful name.
[33:22] And then I do get push origin rename. So
[33:25] we're always notice that get push
[33:27] origin. I'm not doing main anymore. I'm
[33:28] doing rename. Why Corbin? Because we are
[33:31] in the rename branch. We're pushing this
[33:33] code to rename. Enter. That's going to
[33:35] show up in GitHub. Boom. It's going to
[33:37] show up as like, hey, do you want to
[33:38] create a pull request? You don't have to
[33:40] do this right away, but you can. So, you
[33:41] can do compare and pull request. Nice
[33:43] name. Cool. Create pull request. This
[33:45] isn't merging it yet, but now what
[33:47] you'll notice is that now we have an
[33:48] open PR. Nice. In software development,
[33:51] what will happen when you have a
[33:52] multitude team of engineers is you're
[33:55] going to see a ton of PRs. Now, in the
[33:57] actual structuring of a software
[33:58] company, what will occur is that junior
[34:00] engineer here builds a PR or maybe
[34:02] they're just assigned to something else.
[34:03] But the point is that let's just say
[34:04] hypothetically junior engineer gets a PR
[34:06] or makes a PR. I made a PR. Senior
[34:09] engineer checks junior engineer's PR. Is
[34:11] this code good? And then there could
[34:12] even be one level higher than senior
[34:14] engineer that checks that code to make
[34:15] sure we are really good before we go to
[34:17] production. Point being is that this is
[34:19] what creates the development process to
[34:21] ensure that XYZ person that makes code,
[34:23] the code isn't cooked like it's good. If
[34:26] you're a oneman team or one gal team,
[34:27] don't worry about it. You are your own
[34:29] like person that looks at the code to
[34:31] make sure it's not bad. Point being
[34:32] though, as you'll notice, and especially
[34:34] when we were running our teams here, you
[34:35] there's a ton of PRs and sometimes the
[34:37] PRs kind of conflict with each other,
[34:38] but as the higher level engineer, you
[34:40] have to take discretion on making sure
[34:42] if a PR is pushed to main, it looks
[34:44] good, right? Let's take our PR here. We
[34:46] just made together, which is just this,
[34:48] which all we did. We go to commits, we
[34:50] go to files changed, and you know,
[34:52] coffee is good, which is true. That's
[34:53] all that's changed. In theory, if I come
[34:55] over here, go to index.js, or maybe like
[34:58] just go to like unoff landing page.js,
[34:59] GS. I come over here and I change
[35:01] something else. Like I put in a comment
[35:03] like, "Hey, this is cool." Save. Here is
[35:06] a nice little tip. Go on your laptop or
[35:08] your desktop or wherever your keyboard
[35:10] is. Hit up on the arrow keys and you go
[35:12] to pass terminal commit. So I'm going to
[35:13] do get add again. Get commit. I could
[35:15] change it. So I could be like omit added
[35:17] comment added. Enter. And then I do get
[35:19] push origin rename. So now what you just
[35:21] learned there is that within a PR
[35:23] itself, we can do multiple commits which
[35:24] obviously you will do, right? So what
[35:26] you'll notice is that the first one was
[35:27] nice name. The second one was comment
[35:29] added. We go to files changed and now
[35:30] there's two files changed. It's the
[35:32] app.js and the landing page.js as well.
[35:35] Both showing here. Red meaning aviden or
[35:38] probably just tush is gone and then
[35:40] green meaning the new code that is
[35:42] specifically in this branch. So what
[35:44] does this mean? This means that the
[35:47] skill you learned earlier in this video
[35:49] where you're able to roll back on a
[35:50] commit like you mess up in one of these
[35:53] little PRs. Don't worry, there's the
[35:55] little code that you need to copy again.
[35:57] You copy that code and the whole code,
[35:59] not just those that string. You click it
[36:00] and you'll come up here to copy this
[36:02] code, that code, put it into the cursor
[36:03] thing. Hey, can we roll back to this
[36:05] force push? And then you're able to roll
[36:07] back to previous checkpoints that you
[36:08] make here. So your next question is,
[36:10] what is industry standard practice on
[36:12] what makes a good PR essentially, right?
[36:14] This is business to business. This is
[36:15] company to company. Everyone has their
[36:17] own ways of approaching what makes a
[36:19] good PR. But I would say as a general
[36:22] rule of thumb, typically you would go in
[36:24] here to this edit. You would leave
[36:26] comments of things you did. So this is
[36:28] about nice name, but if it's like a
[36:30] feature thing, we say new page made at
[36:32] slash whatever new UI box XYZ. We have
[36:37] the ability to link stuff. We have the
[36:39] ability to put specific code in here. We
[36:41] have the ability to add images here.
[36:42] What I personally like doing and what I
[36:44] tell front-end engineers to do is if you
[36:47] are making a front-end change, add the
[36:49] little bullet point notes. But on top of
[36:50] that, it's a front-end change. So
[36:53] therefore, add an image of the change
[36:54] you made, right? Screenshot it and place
[36:56] it here. Now, last thing you should know
[36:58] is coming over here to reviewers. This
[37:00] is if you had a team. Typically, this is
[37:02] that senior level management or whatever
[37:04] it may be, whoever is reviewing the PR.
[37:06] That's when you would kind of put their
[37:07] name there in your GitHub organization
[37:09] and be like, "Hey, I made the PR." And
[37:11] you probably hit them up on Slack. You
[37:12] DM them on Slack. You're like, "Yo, the
[37:14] PR is ready." You put their name there
[37:16] and then they would confirm it. There's
[37:17] like security. There's like a way deeper
[37:19] tutorial I could get into when it comes
[37:20] to like operationally how to run a
[37:22] business level organization in GitHub.
[37:24] But to be honest with you, I don't think
[37:25] a lot of you'all care about that. If you
[37:26] do, let me know in the comments down
[37:27] below. For now though, assuming look at
[37:29] no conflicts on the branch. I love it.
[37:30] Assuming we made this new branch and
[37:32] we're like, you know what, Corbin, this
[37:33] looks good. You know, maybe it's not
[37:35] profile, maybe it's the new PR, new name
[37:37] PR. This is what I was talking about
[37:38] here. So now this code can go back to
[37:40] main. Therefore, let me show you
[37:41] fundamentally what merge pull request
[37:43] means. Right now, you know for certainty
[37:47] that in the files changed on this
[37:48] separate little branch, it says coffee
[37:51] is good in the app.js.
[37:53] If I go back to my main branch, I'm in
[37:57] main. I go to source. I go to app.js.
[38:00] The exact same file. Notice it says tube
[38:03] stamp. There's the difference. Come back
[38:04] to my pull request. I want to change it
[38:06] now. Merge pull request. Confirm merge.
[38:09] And then standard practice is I can
[38:11] delete that branch. Don't worry if you
[38:13] delete it and you want to grab it back,
[38:15] you can. It's not gone forever. Go back
[38:16] to your mine code and look at this.
[38:18] Merge pull request one and then it tells
[38:21] the name of it. Rename on top of that.
[38:23] Plus two minus two. What does that mean?
[38:25] Plus two lines of code, minus two lines
[38:27] of code. Come back to source. We're in
[38:29] the main now. Go to app.tjs. Coffee is
[38:32] good. So this means that any other
[38:35] future development on the main branch
[38:37] now when I create a branch based off
[38:38] this, it's off the updated version of
[38:41] main. So there's an iteration of how you
[38:43] do a pull request in a GitHub
[38:44] environment. So that's how it looks in
[38:46] the cloud. But what you'll notice is you
[38:48] come back to your code locally on your
[38:50] computer. It's like Corbin. This is a
[38:52] mess. I'm still in rename branch here in
[38:54] the top bottom left. How do I just like
[38:57] refresh start a slate? Don't worry. Go
[38:59] and do get branch again. So you'll
[39:00] notice we're in rename and main.
[39:01] Therefore, I'm going to do get checkout.
[39:03] What checkout means is that now we're in
[39:04] the main branch. But very important for
[39:06] you to understand, this main branch
[39:07] isn't up to date with the cloud code,
[39:09] which I'll show you how to do that
[39:10] pretty soon here. First, let's just
[39:12] delete the local branch of rename. We
[39:13] don't need it anymore. So, we can do get
[39:15] branch-d capital rename. This is going
[39:18] to delete it locally on your computer.
[39:19] We don't need it. Bye-bye. I always like
[39:21] to do get branch again just to confirm.
[39:22] So, now we're in get branch main. So,
[39:23] what you want to notice is we're in
[39:25] main. When I say we're in main, it's
[39:26] this main branch right here. But if I go
[39:28] to app.js, it still says tube stamp. So,
[39:31] what happened? Essentially what happened
[39:33] is that you're playing on an app and you
[39:34] haven't downloaded the update yet. So
[39:36] all you got to do is get pull origin
[39:38] main and watch what happens to stamp.
[39:40] Boom. Coffee is good. So now this code
[39:42] when I do get pull origin and then the
[39:44] branch name is going to be the most
[39:45] up-to-date code relative to this code.
[39:47] You've just successfully connected cloud
[39:49] code to local code perfectly. Make sure
[39:50] you leave a link. Fundamentally that is
[39:52] an important skill to have as another
[39:54] example of this could be let's say you
[39:56] are in a team or maybe it's just you and
[39:58] your friend having a good time. Let's
[39:59] just code for fun, which if it is, make
[40:01] sure to check out the community in the
[40:02] description down below. It's literally
[40:03] going to be like join free community. We
[40:05] got something cool going on here. It's
[40:06] called builder console log. Ask
[40:08] questions. Just think of it like Reddit
[40:10] but for like builders like you and me
[40:11] that want to do really cool stuff all
[40:13] free. Let's run it. So, you have your
[40:16] friends and you guys want to make the
[40:17] next billion dollar app ID. Okay, this
[40:19] is where PRs are fundamental as what a
[40:21] PR allows you to do is everything I just
[40:23] described, but assuming we have a new
[40:24] pull request here that you didn't
[40:26] create. What you want to do is simply
[40:28] and you wanted to check the code
[40:30] locally, eg on your computer, then all
[40:32] you would need to do is simply do get
[40:34] fetch origin and git fetch origin is
[40:36] going to grab all the relevant branches
[40:38] associated with that GitHub repo, which
[40:41] means your friend makes branch called
[40:43] test one two3 and it's right here. I
[40:46] just do the close whatever it's right
[40:47] here. test 123 and you're like how do I
[40:49] access that Corbin? I want to get test
[40:51] one two3 get edge origin and then it's
[40:54] going to be able to get that little
[40:55] branch there and then once you have test
[40:57] get test one two three get branch you do
[40:59] get checkout and then whatever your
[41:01] friend named that branch want to get
[41:02] that out of the way because that is
[41:04] fundamental skill to learn in
[41:06] collaboration software development on
[41:08] top of that if you are kind of confused
[41:10] what I just said there use the chat here
[41:12] and just use the same terminology that I
[41:14] was just using in the in those sentences
[41:16] the same dictation and you'll be fine
[41:17] you have a pretty fundamental idea of
[41:19] what GitHub is now let me show Two last
[41:21] things that are pretty important to kind
[41:22] of put a bow in this entire video. First
[41:24] major thing that you need to understand
[41:26] about GitHub is going to be the ignore
[41:28] file. A lot of people when they first
[41:31] start developing one don't even know
[41:32] what this is, two could just delete it
[41:34] because they're like this just looks
[41:35] weird. But agit ignore does is pretty
[41:39] much in the name. These are files that
[41:41] are ignored and not pushed into the
[41:43] cloud. So let me give you an example of
[41:45] this. A another fundamental file that
[41:47] pairs well with ignore is the env. What
[41:51] aenv is is these are high-risk variables
[41:55] that we store locally on our computer.
[41:57] What's an example of this? Any type of
[42:00] API key. OpenAI's API key you would put
[42:03] in the MMV and then in the ignore you
[42:06] would simply put EMV. So what this will
[42:09] fundamentally do is make it so that when
[42:13] you put high-risk stuff in here and it
[42:15] is read in the EMV here like the getit
[42:18] ignore it is read here you will never
[42:20] see it show up in your code repository
[42:23] you'll never see av file show up here
[42:26] because we placed it in the git ignore
[42:28] there's other stuff that will show up
[42:30] here right different debug logs uh when
[42:32] I say debug log like a console log right
[42:34] you uh you know hello world or like an
[42:36] error log or whatever the reason logs
[42:38] don't show up or you don't want to push
[42:40] logs to GitHub is because sometimes logs
[42:42] can you know put high-risk information
[42:44] in the log itself like hey we tried your
[42:46] open AI key and then just prints out the
[42:48] entire thing in the log that's part of
[42:50] the reason why logs don't show up in
[42:51] GitHub as well also it's kind of
[42:53] annoying dealing with logs in GitHub you
[42:54] don't need them there these are the now
[42:56] you might be like Corbin I want a deep
[42:58] lesson on the EMVs what the heck an EMV
[43:00] is well first off it stands for
[43:02] environment but why is it
[43:04] localdevelopment
[43:07] test.local evenproduction.local
[43:10] like all this craziness. I'm going to
[43:12] reference a series at the end here or
[43:13] you can just go down to the description
[43:14] and you'll see it pretty clearly. It's a
[43:16] three and a half hour series and in this
[43:18] three and a half hour series I go over
[43:20] everything I just speak here. I do it in
[43:22] practice and I build out an actual
[43:23] software. Definitely watch that if
[43:24] you're serious about all this. But as a
[43:27] shorthand TLDDR for this video in my
[43:29] Firebase.js, look at this. My Firebase
[43:32] config. Firebase works with GCP Google
[43:34] Cloud process. This like the back end,
[43:35] right? These are like high-risk
[43:37] variables associated with Firebase,
[43:39] which makes more sense if you watch my
[43:41] videos on it, but essentially these
[43:42] variables, we're not actually giving the
[43:44] real API key here, but we're calling it
[43:47] through the EMV file here. I know this
[43:49] is confusing. Just watch that 3 and 1/2
[43:51] hour series. I'm telling you, you will
[43:53] understand all this and even be way
[43:56] better at it because of all the
[43:57] improvements that have been made with AI
[43:58] and IDEs. Now, your takeaway from that
[44:00] though is simply
[44:02] get ignore. They are important. learn
[44:04] them and understand why we use them. So
[44:06] that three and a half hour series I'll
[44:08] leave in the description down below.
[44:10] Funny enough, the end product of that
[44:12] series was the AI YouTube timestamp that
[44:14] we've been working with here, like a
[44:16] open- source software that you can just
[44:18] download right away to your laptop or
[44:19] desktop. I'll leave this in the
[44:20] description down below, but some of
[44:22] y'all are like, Corbin, you know, three
[44:24] and a half hours of content, that is a
[44:25] lot of content. So then what I suggest
[44:27] you to do if you kind of want like a
[44:28] granularized version of this lesson by
[44:30] lesson, go to that free community, go to
[44:32] classroom here. It's this one right
[44:33] here. build an app with no coding
[44:34] experience and then you can watch each
[44:36] lesson as its own. So lesson one, how do
[44:39] we even create an app? What's the tech
[44:40] stack? Lesson four, how do you create
[44:41] your app's back end? So maybe you're
[44:43] like, you know what, I'm really
[44:44] confident at front end. I don't need to
[44:46] watch Corbin in that. But you're like,
[44:48] I'm a little weaker at the back end.
[44:49] Just check out that lesson right there.
[44:50] You'll be good to go. And here are our
[44:51] last couple shoutouts. If you didn't
[44:53] know, I am one of the only AI
[44:54] influencers that actually streams. And
[44:56] you might be asking yourself, when do
[44:57] you stream, Corbin? Every single day,
[45:00] 6:00 p.m. to 7:00 p.m. PST. I will
[45:02] randomly show up. So, make sure to check
[45:03] me out on stream if you want to stay up
[45:05] to date on new things happening of AI or
[45:07] new things I'm doing or really cool
[45:08] stuff that I see in the industry. Check
[45:10] me out on X. Also, I just do a bunch of
[45:12] random posts as well. Like, don't worry,
[45:13] it isn't going to be like top 10 AI
[45:16] tools. I know you don't care. I know
[45:17] we're all just human here and sometimes
[45:19] you just want to laugh. So, here's like
[45:20] a really funny like stream promo clip I
[45:22] made.
[45:22] >> Nothing beats that bold nacho cheese
[45:24] crunch. We'll make it le stream day 11
[45:27] needs us.
[45:29] >> Stream day 11. Today was stream day 11.
[45:30] I don't know when you're going to join.
[45:31] Also, that's elite lead the llama. If
[45:33] you know, you know. You'll know pretty
[45:34] soon. But that just about does today's
[45:36] video. To feel like you learned
[45:37] something, make sure you leave a like.
[45:38] It is completely free. I know this was a
[45:40] long one. I have a ton of resources on
[45:42] my channel, y'all. There is so many
[45:43] times I'm looking in the comments of
[45:45] people asking specific questions. Just
[45:46] take the 10 seconds, look at my
[45:48] playlist. I guarantee you I've already
[45:50] made a 2 or 3 hour completely free
[45:54] course with me in it teaching you how to
[45:56] do it in this style. So, if you're
[45:58] genuinely interested in creating
[45:59] software with AI, check me out. It's all
[46:02] free. I'm There's no payw wall. No pay
[46:04] wall. But, as you already know, these
[46:05] style videos, I'll see you in the next.
[46:08] Did you just watch the only GitHub video
[46:09] that you ever have to watch in your
[46:10] entire life on the internet from Corbin?
[46:12] Maybe.